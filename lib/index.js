// Generated by CoffeeScript 1.7.1
(function() {
  var EncodedSubdomainName, IPAddressSubdomainName, PATTERN, Server, SubdomainName, decode, dnsserver, encode,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dnsserver = require("dnsserver");

  exports.Server = Server = (function(_super) {
    var NS_C_IN, NS_RCODE_NXDOMAIN, NS_T_A, NS_T_CNAME, NS_T_NS, NS_T_SOA, createSOA, isARequest, isNSRequest;

    __extends(Server, _super);

    NS_T_A = 1;

    NS_T_NS = 2;

    NS_T_CNAME = 5;

    NS_T_SOA = 6;

    NS_C_IN = 1;

    NS_RCODE_NXDOMAIN = 3;

    function Server(domainName, rootAddress) {
      this.rootAddress = rootAddress;
      this.handleRequest = __bind(this.handleRequest, this);
      Server.__super__.constructor.apply(this, arguments);
      this.domainName = domainName.toLowerCase();
      this.soa = createSOA(this.domainName);
      this.on("request", this.handleRequest);
    }

    Server.prototype.handleRequest = function(req, res) {
      var question, subdomainName;
      question = req.question;
      subdomainName = this.extractSubdomainName(question.name);
      if ((subdomainName != null) && isARequest(question)) {
        res.addRR(question.name, NS_T_A, NS_C_IN, 600, subdomainName.getAddress());
      } else if ((subdomainName != null ? subdomainName.isEmpty() : void 0) && isNSRequest(question)) {
        res.addRR(question.name, NS_T_SOA, NS_C_IN, 600, this.soa, true);
      } else {
        res.header.rcode = NS_RCODE_NXDOMAIN;
      }
      return res.send();
    };

    Server.prototype.extractSubdomainName = function(name) {
      return SubdomainName.extract(name, this.domainName, this.rootAddress);
    };

    isARequest = function(question) {
      return question.type === NS_T_A && question["class"] === NS_C_IN;
    };

    isNSRequest = function(question) {
      return question.type === NS_T_NS && question["class"] === NS_C_IN;
    };

    createSOA = function(domainName) {
      var expire, minimum, mname, refresh, retry, rname, serial;
      mname = "ns-1." + domainName;
      rname = "hostmaster." + domainName;
      serial = parseInt(new Date().getTime() / 1000);
      refresh = 28800;
      retry = 7200;
      expire = 604800;
      minimum = 3600;
      return dnsserver.createSOA(mname, rname, serial, refresh, retry, expire, minimum);
    };

    return Server;

  })(dnsserver.Server);

  exports.createServer = function(domainName, address) {
    if (address == null) {
      address = "127.0.0.1";
    }
    return new Server(domainName, address);
  };

  exports.SubdomainName = SubdomainName = (function() {
    SubdomainName.extract = function(name, domainName, address) {
      var constructor, offset, subdomainName;
      if (!name) {
        return;
      }
      name = name.toLowerCase();
      offset = name.length - domainName.length;
      if (domainName === name.slice(offset)) {
        subdomainName = 0 >= offset ? null : name.slice(0, offset - 1);
        if (constructor = this["for"](subdomainName)) {
          return new constructor(subdomainName, address);
        }
      }
    };

    SubdomainName["for"] = function(subdomainName) {
      if (subdomainName == null) {
        subdomainName = "";
      }
      if (IPAddressSubdomainName.pattern.test(subdomainName)) {
        return IPAddressSubdomainName;
      } else if (EncodedSubdomainName.pattern.test(subdomainName)) {
        return EncodedSubdomainName;
      } else {
        return SubdomainName;
      }
    };

    function SubdomainName(subdomainName, address) {
      var _ref;
      this.subdomainName = subdomainName;
      this.address = address;
      this.labels = (_ref = subdomainName != null ? subdomainName.split(".") : void 0) != null ? _ref : [];
      this.length = this.labels.length;
    }

    SubdomainName.prototype.isEmpty = function() {
      return this.length === 0;
    };

    SubdomainName.prototype.getAddress = function() {
      return this.address;
    };

    return SubdomainName;

  })();

  IPAddressSubdomainName = (function(_super) {
    __extends(IPAddressSubdomainName, _super);

    function IPAddressSubdomainName() {
      return IPAddressSubdomainName.__super__.constructor.apply(this, arguments);
    }

    IPAddressSubdomainName.pattern = /(^|\.)((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

    IPAddressSubdomainName.prototype.getAddress = function() {
      return this.labels.slice(-4).join(".");
    };

    return IPAddressSubdomainName;

  })(SubdomainName);

  EncodedSubdomainName = (function(_super) {
    __extends(EncodedSubdomainName, _super);

    function EncodedSubdomainName() {
      return EncodedSubdomainName.__super__.constructor.apply(this, arguments);
    }

    EncodedSubdomainName.pattern = /(^|\.)[a-z0-9]{1,7}$/;

    EncodedSubdomainName.prototype.getAddress = function() {
      return decode(this.labels[this.length - 1]);
    };

    return EncodedSubdomainName;

  })(SubdomainName);

  exports.encode = encode = function(ip) {
    var byte, index, value, _i, _len, _ref;
    value = 0;
    _ref = ip.split(".");
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      byte = _ref[index];
      value += parseInt(byte, 10) << (index * 8);
    }
    return (value >>> 0).toString(36);
  };

  PATTERN = /^[a-z0-9]{1,7}$/;

  exports.decode = decode = function(string) {
    var i, ip, value, _i;
    if (!PATTERN.test(string)) {
      return;
    }
    value = parseInt(string, 36);
    ip = [];
    for (i = _i = 1; _i <= 4; i = ++_i) {
      ip.push(value & 0xFF);
      value >>= 8;
    }
    return ip.join(".");
  };

}).call(this);
